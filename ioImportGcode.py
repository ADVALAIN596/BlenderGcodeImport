# ##### BEGIN GPL LICENSE BLOCK #####
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# ##### END GPL LICENSE BLOCK #####

## blendish python ripped from fro io_import_dxf

import string
import os
import bpy
import mathutils
import math

bl_info = {
    'name': 'Import Slic3r GCode',
    'author': 'Lee Butler',
    'version': (0,1,0),
    'blender': (2, 7, 0),
    'api': 32738,
    'location': 'File > Import-Export > Gcode',
    'description': 'Import and visualize gcode files generated by Slic3r (.gcode)',
    "wiki_url": "",
    "tracker_url": "",
    'category': 'Import-Export'}

__version__ = '.'.join([str(s) for s in bl_info['version']])


class IMPORT_OT_gcode(bpy.types.Operator):
    '''Imports Reprap FDM gcode'''
    bl_idname = "import_scene.gocde"
    bl_description = 'Gcode reader, reads tool moves and animates layer build'
    bl_label = "Import gcode" +' v.'+ __version__
    bl_space_type = "PROPERTIES"
    bl_region_type = "WINDOW"

    filepath = bpy.props.StringProperty(name="File Path", description="Filepath used for importing the GCode file", maxlen= 1024, default= "")

    def __init__(self):
        self.points = []
        self.pos = {'X':10.0, 'Y':20.0, 'Z':30.0, 'E':0.0}
        self.toolState = True
        self.currentLayer = 0

    ##### DRAW #####
    def draw(self, context):
        layout0 = self.layout

    ##### EXECUTE #####
    def execute(self, context):
        print('execute')
        self.parse(self.filepath)
        # import_gcode(self.filepath)
        return {'FINISHED'}

    ##### INVOKE  #####
    def invoke(self, context, event):
        print('invoke')
        wm = context.window_manager
        wm.fileselect_add(self)
        return {'RUNNING_MODAL'}

    ##### PARSE #####
    def parse(self, fileName):
        self.points = []
        self.currentLayer = 0

        # get the object/curve names from the filename
        self.obName = self.filepath.split(os.sep)[-1]
        self.obName = self.obName.replace(".gcode", "")

        f = open(fileName)
        for line in f.readlines():
            # remove comments and leading/trailing whitespace
            line = line.split(';', 1)[0].strip()

            # skip the blank lines
            if len(line) < 1:
                continue

            # tokenize the line
            tokens = line.split()

            self.dispatch(tokens)
            f.close()
        self.genLayer()

    def genProfile(self, profileName):
        # create profile object since it does not exist
        # this should probably be a polyline to save drawing time
        bpy.ops.curve.primitive_bezier_circle_add()
        cir = bpy.data.objects["BezierCircle"]
        bpy.ops.transform.resize( value=[.3, .3, .3] )
        cir.name = profileName
        cir.data.name = profileName + '_curve'

    def genLayer(self):

        if len(self.points) == 0:
            return

        # generate a profile if needed
        # check to see if profile exists
        profileName = self.obName + "Profile"
        print('looking for<' + profileName + '> in:')
        print(bpy.data.objects.keys)
        if profileName not in bpy.data.objects.keys():
            self.genProfile(profileName)

        cir = bpy.data.objects[profileName]

        self.currentLayer = self.currentLayer + 1

        # Create a Blender curve for this layer of the 3d print
        layerName = self.obName + "_curve_ %03d" % self.currentLayer
        curveData = bpy.data.curves.new(layerName, type='CURVE')
        curveData.dimensions = '3D'
        curveData.bevel_object = cir

        polyline = curveData.splines.new('POLY')
        polyline.points.add(len(self.points)-1)

        for i, coord in enumerate(self.points):
            x,y,z = coord
            polyline.points[i].co = (x, y, z, 1)

        # clear out the points we have now used
        self.points = []

        # create object to hold the curve
        curveOB = bpy.data.objects.new(layerName, curveData)
        scn = bpy.context.scene
        scn.objects.link(curveOB)
        scn.objects.active = curveOB
        curveOB.select = True

    ##### DISPATCH #####
    def dispatch(self, tokens):
        if tokens[0] in dir(self):
            eval('self.' + tokens[0] + '(' + str(tokens[1:]) + ')')
        else:
            print( 'unknown command:' + str(tokens[0]))

    def N(self, tokens):
        '''line number and checksum'''
        # checksum not implemented
        self.dispatch(tokens[1:])

    def parseCoords(self, tokens):
        for tok in tokens:
            axis = tok[0]
            if axis in ['X', 'Y', 'Z', 'E']:
                self.pos[axis] = float(tok[1:])

    def G0(self, tokens):
        '''move fast'''
        oldExtrude = self.pos['E']

        self.parseCoords(tokens)
        if self.pos['E'] <= oldExtrude:
            self.genLayer()

        self.points.append([self.pos['X'], self.pos['Y'], self.pos['Z']])


    def G1(self, tokens):
        '''move to'''
        self.G0(tokens)

    def G21(self,tokens):
        '''set units mm'''
        pass

    def G28(self, tokens):
        '''move to origin'''
        self.pos['X'] = 0.0
        self.pos['Y'] = 0.0
        self.pos['Z'] = 0.0
        pass

    def G90(self, tokens):
        '''set absolute positioning'''
        pass

    def G92(self, tokens):
        '''set position'''
        oldExtrude = self.pos['E']

        self.parseCoords(tokens)
        if self.pos['E'] < oldExtrude:
                self.genLayer()

    def M82(self, tokens):
        '''set extruder absolute mode'''
        pass

    def M84(self, tokens):
        '''stop idle hold'''
        pass

    def M104(self,tokens):
        '''set extruder temperature'''
        pass

    def M106(self, tokens):
        '''fan on'''
        pass

    def M107(self,tokens):
        '''fan off'''
        pass

    def M109(self,tokens):
        '''set extruder temperature and wait'''
        pass



def menu_func(self, context):
    self.layout.operator(IMPORT_OT_gcode.bl_idname, text="Slic3r GCode (.gcode)", icon='PLUGIN')

def register():
    bpy.utils.register_module(__name__)
    bpy.types.INFO_MT_file_import.append(menu_func)

def unregister():
    bpy.utils.unregister_module(__name__)
    bpy.types.INFO_MT_file_import.remove(menu_func)

if __name__ == "__main__":
    register()

